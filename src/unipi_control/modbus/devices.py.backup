# import importlib
# import json
# from abc import ABC
# from abc import abstractmethod
# from dataclasses import asdict
# from typing import Dict
# from typing import Iterator
# from typing import List
# from typing import Optional
#
# import itertools
# from pymodbus.client.sync import ModbusSerialClient
# from pymodbus.constants import Endian
# from pymodbus.payload import BinaryPayloadDecoder
#
# from superbox_utils.dict.data_dict import DataDict
# from superbox_utils.text.text import slugify
# from unipi_control.config import Config
# from unipi_control.config import HardwareData
# from unipi_control.config import LogPrefix
# from unipi_control.config import ModbusDeviceInfo
# from unipi_control.config import logger
#
#
# class ModbusDevice(ABC):
#     def __init__(self, config: Config, modbus_rtu_device: str, **kwargs):
#         self.config: Config = config
#
#         self.object_id: str = kwargs["id"]
#         self.friendly_name: str = kwargs["friendly_name"]
#         self.suggested_area: str = kwargs["suggested_area"]
#         self.device: ModbusDeviceInfo = ModbusDeviceInfo(**kwargs["device"])
#         self.address: str = kwargs["address"]
#
#         self.alias: str = kwargs["alias"]
#
#         self.modbus_client = ModbusSerialClient(
#             method="rtu",
#             port=modbus_rtu_device,  # modbus_uart_port  https://github.com/UniPiTechnology/evok/blob/46bfa6cf67db4ab03efffcd2cb10221ee4d2f3da/evok/config.py#L379
#             stopbits=1,  # to yaml file
#             parity=kwargs["parity"],  # to yaml file
#             baudrate=kwargs["baud_rate"],
#         )
#
#     def __repr__(self) -> str:
#         return self.friendly_name
#
#     @property
#     def topic(self) -> str:
#         """Unique name for the MQTT topic."""
#         return f"{self.config.device_info.name.lower()}/{self.object_id or slugify(self.friendly_name.lower())}"
#
#     @abstractmethod
#     def json_attributes(self) -> str:
#         pass
#
#     def connect(self):
#         return self.modbus_client.connect()
#
#     def connected(self):
#         return self.modbus_client.is_socket_open()
#
#
# class BaseSDM(ModbusDevice):
#     def json_attributes(self) -> str:
#         _json_attributes: dict = {}
#
#         self.connect()
#         result = self.modbus_client.read_input_registers(address=0x0000, count=2, slave=1)
#         r = BinaryPayloadDecoder.fromRegisters(result.registers, byteorder=Endian.Big, wordorder=Endian.Big)
#         print("result", float(r.decode_32bit_float()))  # volt
#
#         # try:
#         #     device = getattr(sdm_modbus, self.device.model)(
#         #         device=self.modbus_rtu_device, baud=self.baud_rate, parity=self.parity, slave=self.address
#         #     )
#         #     if device.connected():
#         #         _json_attributes = device.read_all(sdm_modbus.registerType.INPUT, scaling=True)
#         # except AttributeError as e:
#         #     logger.error("%s %s", LogPrefix.MODBUS, e)
#
#         return json.dumps(_json_attributes)
#
#
# class SDM120(BaseSDM):
#     pass
#
#
# class ModbusDeviceMap(DataDict):
#     def __init__(self, config: Config, hardware: HardwareData):
#         super().__init__()
#
#         third_party_definition: Dict[str, dict] = hardware["definitions"]["third_party"]
#
#         for modbus in config.modbus:
#             device_hardware_data: Optional[dict] = third_party_definition[modbus.device.manufacturer.lower()].get(
#                 modbus.device.model
#             )
#
#             if device_hardware_data:
#                 device_category: str = device_hardware_data["category"]
#
#                 if not self.data.get(device_category):
#                     self.data[device_category] = []
#
#                 try:
#                     module_ = importlib.import_module("unipi_control.modbus.devices")
#                     c = getattr(module_, modbus.device.model)(
#                         config,
#                         **device_hardware_data,
#                         **asdict(modbus),
#                         modbus_rtu_device=hardware.data["neuron"]["modbus_rtu_device"],
#                     )
#                     self.data[device_category].append(c)
#                 except (AttributeError, ImportError):
#                     logger.error("%s Can't load modbus device: %s", LogPrefix.MODBUS, device_hardware_data["type"])
#
#     def by_device_category(self, device_category: List[str]) -> Iterator:
#         return itertools.chain.from_iterable(filter(None, map(self.data.get, device_category)))
